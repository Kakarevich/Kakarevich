pwd (print working directory), выведет директорию нахождения
========================================================================================
ls (list directory content),Выдаёт информацию о ФАЙЛАХ (по умолчанию о текущем каталоге).
ls --sort=[вид сортировки] -l <путь>
ls –-sort=size -l ~/
ls –-sort=time -l .
ls -1  Для вывода имен файлов в одноколоночном формате

cd - войти в директорию
cd ..  перемещение назад в каталог
========================================================================================
cp -a ,копирование всех аттрибутов, прав и добавит рекурсию
cp путь_до_файла1 путь_до_файла2 -,копирует файл
cp -r путь_до_дир1 путь_до_дир2 -,копирует директорию целиком
cp -r /ets/default* default   копирование всех фаилов из одной директории в default (корневую, в ней и находясь)
cp -i  копирование с подтверждением
=========================================================================================
mv file1 file_1 ,копирование фаила или переименование
mv file ./dir/ ,перемещает 'file' в 'dir/file' относительно текущего каталога
mv -f ,не запрашивать подтверждения операций.
mv -i ,выводить запрос на подтверждение операции, когда существует файл, в который происходит переименование или перемещение.
mv -- ,завершает список ключей. Применяется для использования с файлами, имена которых начинаются на –.
mv * mydir/   переместить все файли из текущей директории в директорию mydir/
==========================================================================================
cat файл -выводит водержимое файла на экран
Также вы можете использовать утилиту cat для создания текстовых файлов. Введите команду cat > winter.txt, приведенную в примере ниже. После этого введите одну строку или несколько строк текста, завершая ввод каждой из строк нажатием клавиши Enter. После ввода последней строки текста нажмите и удерживайте клавишу Ctrl и одновременно с этим кратковременно нажмите клавишу d. 

~/test$ cat > winter.txt
Сегодня очень холодно!
~/test$ cat winter.txt 
Сегодня очень холодно!
--------------------------------------------------------
Вы можете установить специальный маркер окончания файла для утилиты cat с помощью параметра << таким образом, как показано в примере. Данная конструкция называется локальной директивой (here directive) и позволяет завершать работу процесса cat. 
~/test$ cat > hot.txt <<stop
> Сегодня жарко!
> Да, это лето.
> stop
~/test$ cat hot.txt 
Сегодня жарко!
Да, это лето.
-------------------------------------------
СЛИЯНИЕ С ПОМОЩЬЮ CAT из директории /etc/resolvconf/resolv.conf.d  фаилов head,base,google1,google2  в файл resolv.conf 
$ cat /etc/resolvconf/resolv.conf.d/{head,base,google1,google2} > ./resolv.conf  

~/test$ cat winter.txt    КОПИРОВАНИЕ С ПОМОЩЬЮ CAT
Сегодня очень холодно!
~/test$ cat winter.txt > cold.txt
~/test$ cat cold.txt 
Сегодня очень холодно!
-------------------------------------------------------
cat <файл> | sed ‘инструкция’
sed ‘инструкция’ <файл> потоковый редактор: читает строчки из
			 stdin (или из файла), обрабатывает их по
			 инструкции и пишет в stdout
Если хотим писать в файл:
> <файл> обычное перенаправление
-i, --in-place перезаписать входной файл

Перенаправление в один файл:
&> или &>>
program &>> both.txt
Перенаправление одного потока в другой:
2>&1 stderr в stdout
1>&2 stdout в stderr
Перенаправление в никуда и из ниоткуда:
/dev/null
program 2>/dev/null
cat /dev/null > file.txt
-----------------------------------------------------------
===========================================================

Утилита sed
Редактор потока данных
-----------------------------------------------------------
Редактор потока данных (stream editor) или, для краткости, утилита sed, использует регулярные выражения для модификации потока данных.
В данном примере утилита sed используется для замены строки.

echo Понедельник | sed 's/Понедель/Втор/'
Вторник

Слэши могут быть заменены на некоторые другие символы, которые могут оказаться более удобными и повысить читаемость команды в ряде случаев.

echo Понедельник | sed 's:Понедель:Втор:'
Вторник
echo Понедельник | sed 's_Понедель_Втор_'
Вторник
echo Понедельник | sed 's|Понедель|Втор|'
Вторник
-----------------------------------------------------------
 Интерактивный редактор
Несмотря на то, что утилита sed предназначена для обработки потоков данных, она также может использоваться для интерактивной обработки файлов.

paul@debian7:~/files$ echo Понедельник > today
paul@debian7:~/files$ cat today 
Понедельник
paul@debian7:~/files$ sed -i 's/Понедель/Втор/' today
paul@debian7:~/files$ cat today 
Вторник
-----------------------------------------------------------

Простые обратные ссылки

Символ амперсанда может использоваться для ссылки на искомую (и найденную) строку.
В данном примере амперсанд используется для удвоения количества найденных строк.

echo Понедельник | sed 's/Понедель/&&/'
ПонедельПонедельник
echo Понедельник | sed 's/ник/&&/'
Понедельникник
------------------------------------------------------------
 Обратные ссылки

Круглые скобки используются для группировки частей регулярного выражения, на которые впоследствии могут быть установлены ссылки.
Рассмотрите следующий пример:

paul@debian7:~$ echo Sunday | sed 's_\(Sun\)_\1ny_'
Sunnyday
paul@debian7:~$ echo Sunday | sed 's_\(Sun\)_\1ny \1_'
Sunny Sunday
------------------------------------------------------------

Точка для обозначения любого символа
В регулярном выражении простой символ точки может обозначать любой символ.

paul@debian7:~$ echo 2014-04-01 | sed 's/....-..-../YYYY-MM-DD/'
YYYY-MM-DD
paul@debian7:~$ echo abcd-ef-gh | sed 's/....-..-../YYYY-MM-DD/'
YYYY-MM-DD
------------------------------------------------------------

Множественные обратные ссылки
В случае использования более чем одной пары круглых скобок, ссылка на каждую из них может быть осуществлена путем использования последовательных числовых значений.

paul@debian7:~$ echo 2014-04-01 | sed 's/\(....\)-\(..\)-\(..\)/\1+\2+\3/'
2014+04+01
paul@debian7:~$ echo 2014-04-01 | sed 's/\(....\)-\(..\)-\(..\)/\3:\2:\1/'
01:04:2014


Данная возможность называется группировкой (grouping). 

box@de98796:~$ echo 01.05.1889 | sed 's|\(..\).\(..\).\(....\)|\2/\1/\3|'
05/01/1889
------------------------------------------------------------
 Пробел

Последовательность символов \s может использоваться для ссылки на такой символ, как символ пробела или табуляции.
В данном примере осуществляется глобальный поиск последовательностей символов пробелов (\s), которые заменяются на 1 символ пробела.

paul@debian7:~$ echo -e 'сегодня\tтеплый\tдень'
сегодня	теплый	день
paul@debian7:~$ echo -e 'сегодня\tтеплый\tдень' | sed 's_\s_ _g'
сегодня теплый день
-----------------------------------------------------------------
 Необязательные вхождения

Символ знака вопроса указывает на то, что предыдущий символ является необязательным.
В примере ниже осуществляется поиск последовательности из трех символов o, причем третий символ o является необязательным.

paul@debian7:~$ cat list2
ll
lol
lool
loool
paul@debian7:~$ grep -E 'ooo?' list2
lool
loool
paul@debian7:~$ cat list2 | sed 's/ooo\?/A/'
ll
lol
lAl
lAl
-----------------------------------------------------------
 От n до m повторений
А в данном примере мы четко указываем, что символ должен повторяться от минимального (2) до максимального (3) количества раз.

paul@debian7:~$ cat list2
ll
lol
lool
loool
paul@debian7:~$ grep -E 'o{2,3}' list2
lool
loool
paul@debian7:~$ grep 'o\{2,3\}' list2
lool
loool
paul@debian7:~$ cat list2 | sed 's/o\{2,3\}/A/'
ll
lol
lAl
lAl
paul@debian7:~$
---------------------------------------------------------------

sed ‘s/John/Nick/g’ old.txt > new.txt  заменить все John на Nick
sed -r ‘s/J[a-z]*n/Nick/g’ old.txt > new.txt заменить все слова, которые начинаются на J и кончаются на n на Nick
sed -n ‘2,4p’ file.txt   вывести строки с 2 по 4
sed ‘2,4d’ file.txt      вывести все строки кроме 2-4
sed -n ‘/[0-9]\{2\}/p’ file.txt  вывести строки с 2 цифрами подряд
sed '2,/[Rr]ight/d' file.txt   вывести все строки кроме со 2 до строки  содержащей “right” (с большой или маленькой буквы)



less файл -открывает файл на чтение
   q -выход; /-поиск
   g -в начало; G -в конец
   
nano файл -редактировать файл
   Ctrl + X -выход
==========================================================================================
echo - выводит текст
echo $-     выведетсписок всех параметров командной оболочки

===========================================================================================
rm путь_до_файла -,удаляет файл 
rm {file1,file2,file3}.txt  удаляет несколько файлов
rm -r путь_до_директории -,удаляет пустую директорию (не пустые не удалит)
rm -rf путь_до_директории -,удаляет директорию без вопросов (абсолютно всё)
rm -i    удаляет с подтверждением

rmdir    удалить пустые директории
===========================================================================================
mkdir путь_до_директории -,создает директорию
mkdir ./{dir1,dir2,dir3}
mkdir dir{1..3}
touch путь_до_файла -,создает файл
touch ~/{file1,file2}.txt
> file.txt
============================================================================================
Ctrl + C прервать выполнение
Ctrl + Z приостановить выполнение
fg продоолжить (foreground)
bg продолжить в фоновом режиме (background)
=============================================================================================
chmod +x название_файла.py ,делает файл исполняемым
=============================================================================================
wget ссылка , скачать и сохранить в текущей директории
wget -P путь_до_директории ссылка  ,скачать и сохранить в текущей директории
wget -O путь_до_файла ссылка , скачатьи и сохранить под указанным именем
wget -c ссылка  ,докачать файл
wget -i текстовый_файл  ,скачать несколько файлов по ссылкам из текстового файла
wget --spider ссылка  ,проверить доступность
=============================================================================================
unzip архив.zip  , распаковывает
gunzip архив.gz  , распаковывает и удаляет архив
zip архив.zip файл1 файл2...  , запаковывает
gzip файл  , запаковыет и удаляет исходник
tar -cvf архив.tar файл1 файл2...   запаковывает  без сатия
gzip архив.tar   запаковывает в архив.tar.gz
tar -zcvf архив.tar.gz файл1 файл2 ... запаковать файлы при помощи gzip
tar -xvf архив.tar  распаковать архив.tar
tar -xzvf архив.tar.gz распаковать архив.tar.gz
bzip2 файл
buzip2 файл.bz2
tar -cjvf архив.tar.bz2 файл1 файл2...
tar -xjvf архив.tar.bz2
================================================================================================

find <папка> -name “<имя файла>”   найти указанный файл в папке
find /etc > etcfiles.txt   Команда для поиска всех файлов в директории /etc и сохранения списка имен найденных файлов в файле etcfiles.txt
find / > allfiles.txt   Команда для поиска файлов во всей файловой системе и сохранения списка имен найденных файлов в файле allfiles.txt
find ~/ -name “file.txt”    найти file.txt в домашней директории
find ~/ -name “*.txt”    найти все текстовые файлы в домашней директории
find . -name "*.conf"  Команда для поиска файлов с расширением .conf в текущей директории (и всех поддиректориях)
find . -type f -name "*.conf"  Команда для поиска всех обычных файлов с расширением .conf и явным указанием типа этих файлов (без директорий, именованных каналов и других файлов специальных типов)
find / -type d -name "foo*"  Найти все директории, соответствующие шаблону 'foo*':
find /data -type d -name "*.bak"  Команда для поиска файлов специального типа, представляющих директории, с расширением .bak
find . -newer file42.txt   Команда для поиска файлов, созданных позднее файла file42.txt
find /data -name "*.odf" -exec cp {} /backup/ \;  поиск файлов с расширением *.odf и копируем их в директорию /backup/
find /data -name "*.odf" -ok rm {} \;   файлы с расширением *.odf будут удаляться в том случае, если вы подтвердите необходимость исполнения этой операции для каждого из найденных файлов
find /data -name "*.odf" -ok rm {} \;   Найти все *.conf файлы, расположенные в директории /etc и скопировать их в /backup
find /usr/share/doc -type f -name "*.htm" -exec mv  {}{,l} \;  найдите все обычные файлы с расширением .htm, расположенные в директории /usr/share/doc и во всех ее поддиректориях. Измените расширение на .html для найденных файлов
find -iname “<имя файла>”   не учитывать регистр
find -path “<путь>”      найти указанный путь
find -size <размер>     выводить файлы указанного размера
find -maxdepth <число>  искать не больше чем на заданное число
                        уровней вниз
find -mindepth <число>  искать начиная с заданного числа
                        уровней вниз

grep “<строка>” <файл>   найти строку в файле

grep -с “<строка>” <файл>   посчитать количество вхождений строки
grep -r “<строка>” <папка>   найти строку во всех файлах в папке
grep “hello” file.txt    найти “hello” в файле file.txt
grep -с “123” file.txt    вывести количество раз, которое “123” 					встречается в file.txt
grep -r “world” ~/    найти “world” во всех файлах в домашней 		      директории
grep -l “<строка>” <файл>   список файлов с этой строкой
grep -L “<строка>” <файл>   список файлов, где этой строки нет
grep -n “<строка>” <файл>   выводить номер строки в файле
grep -m <число> “<строка>” <файл>    не искать дальше после    					      заданного числа вхождений
grep -A <число> “<строка>” <файл> выводить это число строк после вхождения

При использовании параметра grep -A1 в вывод также будет добавлена одна строка, располагающаяся после обнаруженной строки.

paul@debian5:~/pipes$ grep -A1 Henin tennis.txt 
Justine Henin, Bel
Serena Williams, usa


grep -B <число> “<строка>” <файл>  выводить это число строк до вхождения

В случае использования параметра grep -B1 в вывод будет добавлена одна строка, располагающаяся до обнаруженной строки.

paul@debian5:~/pipes$ grep -B1 Henin tennis.txt 
Kim Clijsters, BEL
Justine Henin, Bel


grep -C <число> “<строка>” <файл>  выводить это число строк вокруг вхождения
				     
С помощью параметра grep -C1 (контекст) в вывод может быть добавлена одна строка, находящейся до обнаруженной строки, и одна строка, находящаяся после нее. Все три параметра (A, B и C) могут быть использованы для вывода произвольного количества дополнительных строк (например, могут быть использованы параметры A2, B4 или C20).

paul@debian5:~/pipes$ grep -C1 Henin tennis.txt 
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa


grep -E “<шаблон>” <файл>    найти указанный шаблон в файле
grep -E “^go” <файл>    найти строки, начинающиеся с “go”
grep -E “go$” <файл>    найти строки, оканчивающиеся на “go”
grep -E “c[au]t” <файл> найти все слова, содержащие cut и cat
grep -E “ [a-z]ight ” <файл>  слова из 5 букв, кончающиеся на “ight”
grep -E “ [a-z]*ight ” <файл>   слова из 4 и более букв, кончающиеся на “ight”
grep -E “ [a-z]+ight ” <файл>   слова из 5 и более букв, кончающиеся на “ight”
grep -E “ [a-z]?ight ” <файл>   слова из 4-5 букв, кончающиеся на “ight”
grep -E “ [a-zA-Z]*ight ” <файл> слова, кончающиеся на “ight” (разрешены большие буквы)

[paul@RHEL4b pipes]$ cat tennis.txt 
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$ cat tennis.txt | grep Williams
Serena Williams, usa
Venus Williams, USA


grep -i     поиск строк без учета регистра.
[paul@RHEL4b pipes]$ grep Bel tennis.txt 
Justine Henin, Bel
[paul@RHEL4b pipes]$ grep -i Bel tennis.txt 
Kim Clijsters, BEL
Justine Henin, Bel
[paul@RHEL4b pipes]$

grep -v     вывод строк, не содержащих заданную строку.
[paul@RHEL4b pipes]$ grep -v Fra tennis.txt 
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$



grep -vi       для фильтрации всех строк без учета регистра и вывода тех из них, которые не содержат заданной строки.

[paul@RHEL4b pipes]$ grep -vi usa tennis.txt 
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
[paul@RHEL4b pipes]$




-b - показывать номер блока перед строкой;
-c - подсчитать количество вхождений шаблона;
-h - не выводить имя файла в результатах поиска внутри файлов Linux;
-i - не учитывать регистр;
-l - отобразить только имена файлов, в которых найден шаблон;
-n - показывать номер строки в файле;
-s - не показывать сообщения об ошибках;
-v - инвертировать поиск, выдавать все строки кроме тех, что содержат шаблон;
-w - искать шаблон как слово, окружённое пробелами;
-e - использовать регулярные выражения при поиске;
-An - показать вхождение и n строк до него;
-Bn - показать вхождение и n строк после него;
-Cn - показать n строк до и после вхождения;
---------------------------------------------------------------------
paul@rhel65:~$ cat names
Tania
Laura
Valentina
При поиске отдельного символа будут выводиться только те строки, которые содержат заданный символ.
paul@rhel65:~$ grep u names
Laura
paul@rhel65:~$ grep e names
Valentina
paul@rhel65:~$ grep i names
Tania
Valentina

 Для поиска сочетаний символов в строках символы регулярного выражения должны объединяться аналогичным образом.
В данном примере демонстрируется принцип работы утилиты grep, в соответствии с которым регулярному выражению ia будет соответствовать строка Tania, но не строка Valentina, а регулярному выражению in - строка Valentina, но не строка Tania.

paul@rhel65:~$ grep a names
Tania
Laura
Valentina
paul@rhel65:~$ grep ia names
Tania
paul@rhel65:~$ grep in names
Valentina
paul@rhel65:~$
----------------------------------------------------------------
 Один или другой символ
Как в синтаксисе PCRE, так и в синтаксисе ERE может использоваться символ создания программного канала, который в данном случае будет представлять логическую операцию "ИЛИ". В данном примере мы будем искать с помощью утилиты grep строки, в которых встречается символ i или символ a.

paul@debian7:~$ cat list 
Tania
Laura
paul@debian7:~$ grep -E 'i|a' list 
Tania
Laura

Обратите внимание на то, что мы используем параметр -E утилиты grep для принудительной интерпретации нашего регулярного выражения как выражения, использующего расширенный синтаксис регулярных выражений (ERE).
Нам придется экранировать символ создания программного канала в регулярном выражении, использующем базовый синтаксис регулярных выражений (BRE) для аналогичной интерпретации этого символа в качестве логической операции "ИЛИ".

paul@debian7:~$ grep -G 'i|a' list 
paul@debian7:~$ grep -G 'i\|a' list 
Tania
Laura
----------------------------------------------------------------------
 Одно или большее количество совпадений
Символ * соответствует нулю, одному или большему количеству вхождений предыдущего символа, а символ + одному или большему количеству вхождений предыдущего символа ﻿.

paul@debian7:~$ cat list2
ll
lol
lool
loool
paul@debian7:~$ grep -E 'o*' list2
ll
lol
lool
loool
paul@debian7:~$ grep -E 'o+' list2
lol
lool
loool
paul@debian7:~$
--------------------------------------------------------------------------

 Совпадение в конце строки
В следующих примерах мы будем использовать данный файл:

paul@debian7:~$ cat names 
Tania
Laura
Valentina
Fleur
Floor


В двух примерах ниже показана методика использования символа доллара для поиска совпадения в конце строки.

paul@debian7:~$ grep a$ names 
Tania
Laura
Valentina
paul@debian7:~$ grep r$ names 
Fleur
Floor
----------------------------------------------------------------------------

 Совпадение в начале строки

Символ вставки (^) позволяет осуществлять поиск совпадения в начале (или с первых символов) строки.
В данных примерах используется рассмотренный выше файл.

paul@debian7:~$ grep ^Val names 
Valentina
paul@debian7:~$ grep ^F names 
Fleur
Floor

Символы доллара и вставки, используемые в регулярных выражениях, называются якорями (anchors). 
----------------------------------------------------------------------------------------------
 Разделение слов
Последовательность символов \b может использоваться в регулярных выражениях в качестве разделителя слов. Рассмотрим в качестве примера следующий файл:

paul@debian7:~$ cat text
The governer is governing.
The winter is over.
Can you get over there?


При простом поиске строки over будет выведено слишком много результирующих строк.

paul@debian7:~$ grep over text
The governer is governing.
The winter is over.
Can you get over there?


Экранирование разыскиваемых слов с помощью символов пробелов не является удачным решением (так как другие символы также могут использоваться в качестве разделителей слов). В примере ниже показана методика использования последовательности символов \b для поиска строк с заданным словом, а не последовательностью символов:

paul@debian7:~$ grep '\bover\b' text
The winter is over.
Can you get over there?
paul@debian7:~$

Обратите внимание на то, что утилита grep также поддерживает параметр -w, предназначенный для осуществления поиска по словам.

paul@debian7:~$ cat text 
The governer is governing.
The winter is over.
Can you get over there?
paul@debian7:~$ grep -w over text
The winter is over.
Can you get over there?
paul@debian7:~$ 
------------------------------------------------------
 Предотвращение раскрытия регулярного выражения командной оболочкой
Символ доллара является специальным символом как для регулярного выражения, так и для командной оболочки (вспомните о переменных командной оболочки и встраиваемых командных оболочках). Исходя из этого, рекомендуется при любых обстоятельствах экранировать регулярные выражения, так как экранирование регулярного выражения позволяет предотвратить раскрытие этого выражения командной оболочкой.

paul@debian7:~$ grep 'r$' names 
Fleur
Floor
rename

=========================================================
=========================================================



Обновление ссылок на пакеты:
sudo apt-get update

Обновление установленных пакетов:
sudo apt-get upgrade

Обновление отдельной программы:
sudo apt-get intall --only-upgrade программа

==============================================================================================


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++   +++   +++     ПЕРЕНАПРАВЛЕНИЕ ЗАПИСИ      +++   +++    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Программа < файл   брать stdin из файла

Программа > файл   выводить stdout в файл
Программа >> файл   аналогично, но с дозаписью файл

Программа 2> файл   выводить stderr в файл
Программа 2>> файл   аналогично, но с дозаписью файл



++++++++++++++++++++++   +++   +++     СЕРВЕР     +++   +++    +++++++++++++++++++++++++++++++

ssh логин@адрес_сервера -p порт

sh-keygen  cоздание ключа
ssh-add    сообщить системе о ключе
cat ~/.ssh/id_rsa.pub    просмотр публичного ключа
nano ~/.ssh/authorised_keys   редактирование авторизованных ключей (на сервере)

scp -P порт логин@адрес_сервера:путь1 путь2       копирование с сервера (путь1) на клиента (путь2)
 
scp -P порт путь1 логин@адрес_сервера:путь2       копирование с клиента (путь1) на сервер (путь2)

scp -r box@server1.stepik-local:/srv/files_on_server/* /home/box/files_on_client/  копирование из одной папки в другую (сама папка не копируется)

==============================================================================================

jobs   посмотреть список запущенных программ

fg %<номер>   продолжить программу с этим номером
bg %<номер>   продолжить программу с этим номером в фоновом режиме

ps     посмотреть ваши процессы

top    отслеживать процессы в реальном времени
top -u имя_пользователя    отслеживать процессы этого пользователя

kill номер_процесса    завершить процесс с этим номером
kill -9 номер_процесса    "убить" процесс с этим номером (мгновенно завершает)
===============================================================================================
                 информация о компьютере
free -g      информация об оперативной памяти
nproc     количество ядер
lscpu     детальная информация




=================================================================================================
====  =====  =====  =====  =====  =====  ======  ======  ======  =======  ======  =====  ====    

Стандартные команды Git используемые в различных ситуациях:

создание рабочей области (смотрите также: git help tutorial)
   clone             Клонирование репозитория в новый каталог
   init              Создание пустого репозитория Git или переинициализация существующего
____________________________________________________________________________________________
работа с текущими изменениями (смотрите также: git help everyday)
   add               Добавление содержимого файла в индекс
   mv                Перемещение или переименование файла, каталога или символьной ссылки
   restore           Restore working tree files
   rm                Удаление файлов из рабочего каталога и индекса
   sparse-checkout   Initialize and modify the sparse-checkout
_______________________________________________________________________________________________
просмотр истории и текущего состояния (смотрите также: git help revisions)
   bisect            Выполнение двоичного поиска коммита, который вносит ошибку
   diff              Вывод разницы между коммитами, коммитом и рабочим каталогом и т.д.
   grep              Вывод строк, соответствующих шаблону
   log               Вывод истории коммитов
   show              Вывод различных типов объектов
   status            Вывод состояния рабочего каталога
___________________________________________________________________________________________
выращивание, отметка и настройка вашей общей истории
   branch            Вывод списка, создание или удаление веток
   commit            Запись изменений в репозиторий
   merge             Объединение одной или нескольких историй разработки вместе
   rebase            Повторное применение коммитов над верхушкой другой ветки
   reset             Сброс текущего состояния HEAD на указанное состояние
   switch            Switch branches
   tag               Создание, вывод списка, удаление или проверка метки, подписанной с помощью GPG

совместная работа (смотрите также: git help workflows)
   fetch             Загрузка объектов и ссылок из другого репозитория
   pull              Извлечение изменений и объединение с другим репозиторием или локальной веткой
   push              Обновление внешних ссылок и связанных объектов

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++   ++++    ++++++++++++++++++ tmux +++++++++++++++++++++++    ++++   +++   ++++   +++++++++++++++

Ctrl + Shift + T    открыть новую вкладку в терминале
Alt + <цифра>       перейти в указанную вкладку
Ctrl + Shift + W     закрыть текущую вкладку
tmux                 запустить tmux
Ctrl +                Bперейти в режим команд
Ctrl + B и C (зажать Ctrl+B, отпустить,затем нажать С)  создать новую вкладку
Ctrl + B и <цифра>    перейти в указанную вкладку
Ctrl + B и N / Ctrl + B и P перейти в следующую / предыдущую вкладку
Ctrl + B и X (или exit) закрыть вкладку
Ctrl + B и D          временно выйти из tmux
tmux attach / tmux a  вернуться в tmux
tmux list-sessions    посмотреть список запущенных tmux’ов
Ctrl + B и PgUp       перейти в режим просмотра истории
PgUp, PgDown, стрелки  перемещать курсор по истории
Esc, Ctrl + C          выйти из режима просмотра истории
Ctrl + B и ,           переименовать закладку
Ctrl+B и "             разделение горизонтальное
Ctrl+B и %             разделение вертивальное

=================================================================================
Права доступа
---------------------------------
Права у файлов:
r – просмотр содержимого
w – редактирование
x – запуск
----------------------------------
Изменить права доступа:
chmod [ugoa][+-][rwx] <путь>
chmod ug+rw file.txt
chmod [octal code] <путь>
chmod 777 file.txt

Изменить права доступа:
chmod [ugoa][+-][rwx] <путь>
chmod ug+rw file.txt
chmod [octal code] <путь>
chmod 777 file.txt
Изменить обладателя:
chown new_user:new_group <путь>
chown zoidberg file.txt
chown :futurama file.txt
--------------------------------------------------------
Посчитать что-то в файле:
wc [что-считаем] <путь>

wc -l file.txt вывести количество строк
wc -c file.txt вывести количество байт
wc -m file.txt вывести количество символов
wc -L file.txt вывести длину самой длинной строки
wc -w file.txt вывести количество слов
-------------------------------------------------------
Сравнить файлы/директории:
diff [-q -r] <путь1> <путь2>
diff file1.txt file2.txt | less
diff -qr dir1/ dir2/
-------------------------------------------------------
Узнать сколько места занимаем на диске:
du [--max-depth <глубина> -h] <путь>
du -h ~/      показывает всё в удобном для чтения формате углубленно
du –-max-depth 1 -h .   показывает всё в удобном для чтения формате поверхностно
df [-h]
узнать сколько места занято/свободно
во всей системе
-------------------------------------------------------
Вывести часть файла:
head [-n <количество строк>] <путь>  выводит первые 10 строк
tail [-n <количество строк>] <путь>  выводит последние 10 строк

head -n 10 file.txt
head -4 /etc/passwd
tail -n 50 file.txt | less
------------------------------------------------------

Предназначение утилиты tac (в отличие от утилиты cat) может быть проиллюстрировано с помощью единственного примера
~/test$ cat count 
один
два
три
четыре
~/test$ tac count 
четыре
три
два
один
-------------------------------------------------------

which 
Команда which осуществляет поиск бинарных файлов в директории, заданной с помощью переменной окружения $PATH (переменные будут рассматриваться позднее). В примере ниже устанавливается, что cd является встроенной командой, а ls, cp, rm, mv, mkdir, pwd и which - внешними командами. 

root@RHEL4b ~]# which cp ls cd mkdir pwd 
/bin/cp
/bin/ls
/usr/bin/which: no cd in (/usr/kerberos/sbin:/usr/kerberos/bin:...
/bin/mkdir
/bin/pwd
=======================================================================

alias  создает псевдонимы
paul@laika:~$ alias ll='ls -lh --color=auto'
paul@laika:~$ alias c='clear'

[paul@RHELv4u3 ~]$ rm -i winter.txt 
rm: удалить обычный файл "winter.txt"? no
[paul@RHELv4u3 ~]$ rm winter.txt 
[paul@RHELv4u3 ~]$ ls winter.txt
ls: невозможно получить доступ к winter.txt: Нет такого файла или каталога
[paul@RHELv4u3 ~]$ touch winter.txt
[paul@RHELv4u3 ~]$ alias rm='rm -i'
[paul@RHELv4u3 ~]$ rm winter.txt 
rm:удалить пустой обычный файл "winter.txt"? no

Исполнение команды без аргументов приведет к выводу полного списка используемых на данный момент псевдонимов
paul@laika:~$ alias 
alias c='clear'
alias ll='ls -lh --color=auto'
==========================================================================

unalias   прекратить использование псевдонима команды,

paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$ alias rm='rm -i'
[paul@RHEL4b ~]$ which rm
alias rm='rm -i'
        /bin/rm
[paul@RHEL4b ~]$ unalias rm
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$
==============================================================================

Вывод информации о раскрытии команд командной оболочкой
set -x  выводить инфу об раскрытии команд
set +x  отменить вывод

[paul@RHELv4u3 ~]$ set -x
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo $USER
+ echo paul
paul
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo \$USER
+ echo '$USER'
$USER
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ set +x
+ set +x
[paul@RHELv4u3 ~]$ echo $USER
paul
---------------------------------------
Несвязанные переменные
paul@laika:~$ set -u
paul@laika:~$ echo $Myvar
bash: Myvar: unbound variable
paul@laika:~$ set +u
paul@laika:~$ echo $Myvar

paul@laika:~$
В командной оболочке bash команда set -u идентична команде set -o nounset и, по аналогии, команда set +u идентична команде set +o nounset. 
===============================================================================

Двойная вертикальная черта (||)
Оператор || представляет логическую операцию "ИЛИ". Вторая команда исполняется только тогда, когда исполнение первой команды заканчивается неудачей (возвращается ненулевой код завершения). 

paul@barry:~$ echo первая команда || echo вторая команда ; echo третья команда
первая команда
третья команда
paul@barry:~$ zecho первая команда || echo вторая команда ; echo третья команда
-bash: zecho: команда не найдена...
вторая команда
третья команда
paul@barry:~$
====================================================================
Экранирование специальных символов (\)
[paul@RHELv4u3 ~]$ echo hello \; world
hello ; world
[paul@RHELv4u3 ~]$ echo hello\ \ \ world
hello   world
[paul@RHELv4u3 ~]$ echo экранирование \\\ \#\ \&\ \"\ \'
экранирование \ # & " '
[paul@RHELv4u3 ~]$ echo экранирование \\\?\*\"\'
экранирование \?*"'

Обратный слэш в конце строки
[paul@RHEL4b ~]$ echo Данная строка команды \
> разделена на три \
> части
Данная строка команды разделена на три части
[paul@RHEL4b ~]$
=======================================================================
set | more   вывести список переемнных
unset <переменная>  удаляет переменную
-----------------------------------------------------------------------

-------------------------------------------------------
Переменная окружения $PATH
Переменная окружения $PATH устанавливает директории файловой системы, в которых командная оболочка ищет бинарные файлы, необходимые для исполнения команд (за исключением тех случаев, когда команда является встроенной или представлена псевдонимом команды). Данная переменная содержит список путей к директориям с символами двоеточия в качестве разделителей.

[[paul@RHEL4b ~]$ echo $PATH
/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:


Командная оболочка не будет осуществлять поиск бинарных файлов, которые могут быть исполнены, в текущей директории. (Функция поиска исполняемых файлов в текущей директории являлась простейшим механизмом несанкционированного доступа к данным, хранящимся на компьютерах под управлением PC-DOS). В том случае, если вы хотите, чтобы командная оболочка осуществляла поиск исполняемых файлов в текущей директории, вам следует добавить символ . в конец строки, являющейся значением переменной $PATH вашей командной оболочки.

[paul@RHEL4b ~]$ PATH=$PATH:.
[paul@RHEL4b ~]$ echo $PATH
/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:.
[paul@RHEL4b ~]$


Значение переменной $PATH вашей командной оболочки может отличаться в случае использования команды su вместо команды su -, так как последняя команда позволяет дополнительно использовать значения переменных окружения целевого пользователя. К примеру, в представленный значением переменной $PATH список директорий пользователя root обычно добавляются директории /sbin.

[paul@RHEL3 ~]$ su
Password: 
[root@RHEL3 paul]# echo $PATH
/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin
[root@RHEL3 paul]# exit
[paul@RHEL3 ~]$ su -
Password: 
[root@RHEL3 ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:
[root@RHEL3 ~]#
=======================================================================
Разграничения переменных

[paul@RHEL4b ~]$ prefix=Super
[paul@RHEL4b ~]$ echo Привет $prefixman и $prefixgirl
Привет  и
[paul@RHEL4b ~]$ echo Привет ${prefix}man и ${prefix}girl
Привет Superman и Supergirl
[paul@RHEL4b ~]$

-----------------
Встраивание командных оболочек
Командные оболочки могут подвергаться встраиванию в рамках строк команд или, другими словами, в ходе разбора строк команд могут создаваться новые процессы, являющиеся копиями процесса текущей командной оболочки. Вы можете использовать переменные для доказательства факта создания новых командных оболочек. В примере ниже переменная $var1 существует исключительно в рамках дочерней (временной) командной оболочки. 

[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$ echo $(var1=5;echo $var1)
5
[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$
--------------------------

paul@deb503:~$ A='командная оболочка'
paul@deb503:~$ echo $C$B$A $(B='встроенная ';echo $C$B$A; echo $(C='встроенная ';echo $C$B$A))
командная оболочка встроенная командная оболочка встроенная встроенная командная оболочка
--------------------------
 Обратные кавычки
Однократное встраивание командной оболочки может оказаться полезным в том случае, если необходимо избежать изменения текущей директории. В примере ниже для встраивания командной оболочки используются обратные кавычки вместо рассмотренного ранее символа доллара со скобками.

[paul@RHELv4u3 ~]$ echo `cd /etc; ls -d * | grep pass`
passwd passwd- passwd.OLD
[paul@RHELv4u3 ~]$

 Обратные кавычки или одинарные кавычки
Размещение встраиваемых команд между обратными кавычками вместо круглых скобок со знаком доллара позволяет отказаться от использования одного дополнительного символа. Однако, следует быть очень осторожным, так как обратные кавычки часто путают с одинарными кавычками. В техническом плане различия между кавычками ' и ` являются значительными.

[paul@RHELv4u3 gen]$ echo `var1=5;echo $var1`
5
[paul@RHELv4u3 gen]$ echo 'var1=5;echo $var1'
var1=5;echo $var1
[paul@RHELv4u3 gen]$
------------------------------------------------------
ПОВТОРЕНИЕ КОМАНД
Вы можете повторить другие команды, воспользовавшись символом !, после которого должен быть введен один или несколько начальных символов команды. В результате командная оболочка повторит последнюю команду, начинающуюся с введенных символов.

paul@debian5:~/test42$ touch file42
paul@debian5:~/test42$ cat file42
paul@debian5:~/test42$ !to
touch file42
paul@debian5:~/test42$

---------------
Команда history
Для просмотра списка исполненных ранее команд следует использовать команду history, которая позволяет вывести информацию об истории команд, выполненных в рамках данной командной оболочки (или использовать команду history n для ознакомления со списком из n последних выполненных команд).

paul@debian5:~/test$ history 10
38  mkdir test
39  cd test
40  touch file1
41  echo привет > file2
42  echo Сегодня очень холодно > winter.txt
43  ls
44  ls -l
45  cp winter.txt summer.txt
46  ls -l
47  history 10
-----------------------
-----------------------
-----------------------
Команда !n
При вводе символа ! с последующим вводом номера команды для повторения, командная оболочка выведет строку соответствующей команды и исполнит ее.

paul@debian5:~/test$ !43
ls
file1  file2  summer.txt  winter.txt
------------------
------------------
------------------
Сочетание клавиш Ctrl-r
Другой вариант методики осуществления поиска в истории команд заключается в использовании сочетания клавиш ctrl-r. В примере ниже я использовал сочетание клавиш ctrl-r и ввел четыре символа apti, после чего в файле истории команд командной оболочки был осуществлен поиск последней команды, содержащей последовательность из этих четырех символов.

paul@debian5:~$ 
(reverse-i-search)`apti': sudo aptitude install screen
------------------
Переменная окружения $HISTSIZE
Переменная $HISTSIZE устанавливает количество команд, которые будут сохраняться при работе в вашем текущем окружении. Большинство дистрибутивов устанавливает стандартное значение данной переменной, равное 500 или 1000.

paul@debian5:~$ echo $HISTSIZE
500


Вы можете изменить значение данной переменной на любое желаемое.

paul@debian5:~$ HISTSIZE=15000
paul@debian5:~$ echo $HISTSIZE
15000
---------------------------------
Переменная окружения $HISTFILE
Переменная $HISTFILE указывает на файл, который содержит данные истории команд вашей командной оболочки. В командной оболочке bash стандартным значением данной переменной является путь к файлу ~/.bash_history.

paul@debian5:~$ echo $HISTFILE
/home/paul/.bash_history
-------------------------------
Переменная окружения $HISTFILESIZE
Количество команд, сохраняемых в вашем файле истории команд, может быть установлено с помощью переменной окружения $HISTFILESIZE.

paul@debian5:~$ echo $HISTFILESIZE
15000



---------------------------------------------------------------------------
===========================================================================

Регулярные выражения (дополнительная информация)
Имеется возможность использования регулярных выражений в случае использования символа ! для повтора команд. В примере ниже перед повторным исполнением команды производится замена символа 1 на символ 2 в строке этой команды.

paul@debian5:~/test$ cat file1
paul@debian5:~/test$ !c:s/1/2
cat file2
hello
paul@debian5:~/test$

---------------------------------------------------------------------------
---------------------------------------------------------------------------
===========================================================================

=====Звездочка (*)======
Звездочка * интерпретируется командной оболочкой как символ для генерации списка имен файлов, причем сам символ звездочки может преобразовываться в любую комбинацию символов (или даже в строку без символов). В том случае, если не задано пути к директории для формирования списка имен файлов, командная оболочка будет использовать имена файлов из текущей директории. Обратитесь к странице руководства glob(7) для получения дополнительной информации. (Данный вопрос также рассматривается в теме LPI 1.103.3.)

[paul@RHELv4u3 gen]$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File*
File4  File55  FileA  Fileab  FileAB
[paul@RHELv4u3 gen]$ ls file*
file1  file2  file3  fileab  fileabc
[paul@RHELv4u3 gen]$ ls *ile55
File55
[paul@RHELv4u3 gen]$ ls F*ile55
File55
[paul@RHELv4u3 gen]$ ls F*55
File55
[paul@RHELv4u3 gen]$


====Знак вопроса (?)====
Аналогично звездочке, знак вопроса ? интерпретируется командной оболочкой как символ для генерации списка имен файлов, причем сам знак вопроса соответствует ровно одному символу имени файла.

[paul@RHELv4u3 gen]$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File?
File4  FileA
[paul@RHELv4u3 gen]$ ls Fil?4
File4
[paul@RHELv4u3 gen]$ ls Fil??
File4  FileA
[paul@RHELv4u3 gen]$ ls File??
File55  Fileab  FileAB
[paul@RHELv4u3 gen]$

=====Квадратные скобки ([])=====
Открывающаяся квадратная скобка [ интерпретируется командной оболочкой как символ для генерации списка имен файлов, соответствующий любым из символов, находящихся между символом [ и первым следующим за ним символом ]. Порядок следования символов в списке между скобками не имеет значения. Каждая пара символов скобок заменяется ровно на один символ.

[paul@RHELv4u3 gen]$ ls 
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File[5A]
FileA
[paul@RHELv4u3 gen]$ ls File[A5]
FileA
[paul@RHELv4u3 gen]$ ls File[A5][5b]
File55
[paul@RHELv4u3 gen]$ ls File[a5][5b]
File55  Fileab
[paul@RHELv4u3 gen]$ ls File[a5][5b][abcdefghijklm]
ls: невозможно получить доступ к File[a5][5b][abcdefghijklm]: Нет такого файла или каталога
[paul@RHELv4u3 gen]$ ls file[a5][5b][abcdefghijklm]
fileabc
[paul@RHELv4u3 gen]$


Также с помощью символа восклицательного знака ! вы можете исключать символы из списка, расположенного между квадратными скобками. Кроме того, у вас имеется возможность создания комбинаций из описанных выше шаблонов.

[paul@RHELv4u3 gen]$ ls 
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls file[a5][!Z]
fileab
[paul@RHELv4u3 gen]$ ls file[!5]*
file1  file2  file3  fileab  fileabc
[paul@RHELv4u3 gen]$ ls file[!5]?
fileab
[paul@RHELv4u3 gen]$


=====Диапазоны a-z и 0-9=====
Командная оболочка bash также распознает объявления диапазонов символов между квадратными скобками.

[paul@RHELv4u3 gen]$ ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ ls file[a-z]*
fileab  fileab2  fileabc
[paul@RHELv4u3 gen]$ ls file[0-9]
file1  file2  file3
[paul@RHELv4u3 gen]$ ls file[a-z][a-z][0-9]*
fileab2
[paul@RHELv4u3 gen]$

-----------------------------------------------------
Предотвращение формирования списков имен файлов на основе шаблонов
В примере ниже не должно быть ничего удивительного. При использовании команды echo * в пустой директории будет выведен символ *. А при использовании той же команды в директории с файлами будут выведены имена всех файлов.

paul@ubu1010:~$ mkdir test42
paul@ubu1010:~$ cd test42
paul@ubu1010:~/test42$ echo *
*
paul@ubu1010:~/test42$ touch file42 file33
paul@ubu1010:~/test42$ echo *
file33 file42


Формирование списков имен файлов на основе шаблонов может быть предотвращено путем помещения специальных символов в кавычки, а также экранирования этих символов таким образом, как показано в примере ниже.

paul@ubu1010:~/test42$ echo *
file33 file42
paul@ubu1010:~/test42$ echo \*
*
paul@ubu1010:~/test42$ echo '*'
*
paul@ubu1010:~/test42$ echo "*"
*
=====================================================================
=====================================================================
=====================================================================

Параметр командной оболочки noclobber

Удаление содержимого файла при использовании оператора > может быть предотвращено путем установки параметра командной оболочки noclobber.

[paul@RHELv4u3 ~]$ cat winter.txt 
Сегодня холодно! 
[paul@RHELv4u3 ~]$ set -o noclobber 
[paul@RHELv4u3 ~]$ echo Сегодня холодно! > winter.txt 
-bash: winter.txt: не могу переписать уже существующий файл 
[paul@RHELv4u3 ~]$ set +o noclobber 
[paul@RHELv4u3 ~]$
---------------------------------------------------------------------
 

Нейтрализация влияния параметра командной оболочки noclobber

Влияние параметра командной оболочки noclobber может быть нейтрализовано с помощью оператора >|.

[paul@RHELv4u3 ~]$ set -o noclobber 
[paul@RHELv4u3 ~]$ echo Сегодня холодно! > winter.txt 
-bash: winter.txt: не могу переписать уже существующий файл 
[paul@RHELv4u3 ~]$ echo Сегодня очень холодно! >| winter.txt 
[paul@RHELv4u3 ~]$ cat winter.txt 
Сегодня очень холодно! 
[paul@RHELv4u3 ~]$
--------------------------------------------------------------------

Оператор дополнения >>

Следует использовать оператор >> для записи данных из стандартного потока вывода в конец файла без предварительного удаления содержимого этого файла.

[paul@RHELv4u3 ~]$ echo Сегодня холодно! > winter.txt 
[paul@RHELv4u3 ~]$ cat winter.txt 
Сегодня холодно! 
[paul@RHELv4u3 ~]$ echo Когда же наступит лето ? >> winter.txt 
[paul@RHELv4u3 ~]$ cat winter.txt 
Сегодня холодно! Когда же наступит лето ?
[paul@RHELv4u3 ~]$
-------------------------------------------------------------------

Операция перенаправления потока данных stderr (2>)

Перенаправление стандартного потока ошибок осуществляется с помощью оператора 2>. Такое перенаправление может оказаться очень полезным для предотвращения заполнения вашего экрана сообщениями об ошибках.

[paul@RHELv4u3 ~]$ find / > allfiles.txt 2> /dev/null 
[paul@RHELv4u3 ~]$
--------------------------------------------------------------------

Операция перенаправления нескольких потоков данных 2>&1

Для перенаправления данных как из стандартного потока вывода, так и из стандартного потока ошибок в один и тот же файл следует использовать конструкцию 2>&1.

[paul@RHELv4u3 ~]$ find / > allfiles_and_errors.txt 2>&1 
[paul@RHELv4u3 ~]$

Помните о том, что последовательность операций перенаправления потоков данных имеет значение. К примеру, команда

ls > dirlist 2>&1

позволяет перенаправить как данные из стандартного потока вывода (с файловым дескриптором 1), так и данные из стандартного потока ошибок (с файловым дескриптором 2) в файл dirlist, в то время, как команда

ls 2>&1 > dirlist

позволяет перенаправить только данные из стандартного потока вывода в файл dirlist, так как с помощью данной команды осуществляется копирование дескриптора стандартного потока вывода в дескриптор стандартного потока ошибок перед тем, как стандартный поток вывода перенаправляется в файл dirlist.
---------------------------------------------------------------------

Объединение стандартных потоков вывода stdout и ошибок stderr

Конструкция &> позволяет объединить стандартные потоки вывода stdout и ошибок stderr в рамках одного потока данных (причем данные будут сохраняться в файле).

paul@debian7:~$ rm file42 &> out_and_err 
paul@debian7:~$ cat out_and_err rm: невозможно удалить "file42": Нет такого файла или каталога paul@debian7:~$ echo file42 &> out_and_err paul@debian7:~$ cat out_and_err file42 paul@debian7:~$ 
-------------------------------------------------------------------


Перенаправление стандартного потока ввода

Операция перенаправления потока данных stdin (<)

Перенаправление стандартного потока ввода stdin осуществляется с помощью оператора < (являющегося краткой версией оператора 0<).

[paul@RHEL4b ~]$ cat < text.txt one two 
[paul@RHEL4b ~]$ tr 'onetw' 'ONEZZ' < text.txt ONE ZZO 
[paul@RHEL4b ~]$
------------------------------------------
 
Структура < here document

Структура here document (иногда называемая структурой here-is-document) является механизмом для ввода данных до момента обнаружения определенной последовательности символов (обычно EOF). Маркер EOF может быть либо введен вручную, либо вставлен автоматически при нажатии комбинации клавиш Ctrl-D.

[paul@RHEL4b ~]$ cat <EOF > text.txt > один > два > EOF 
[paul@RHEL4b ~]$ cat text.txt один два 
[paul@RHEL4b ~]$ cat <brol > text.txt > brel > brol 
[paul@RHEL4b ~]$ cat text.txt brel 
[paul@RHEL4b ~]$
--------------------------------------------

Структура < here string

Структура here string может использоваться для непосредственной передачи строк команде. При использовании данной структуры достигается такой же эффект, как и при использовании команды echo строка | команда (но вы сможете избежать создания одного дополнительного процесса).

paul@ubu1110~$ base64 < linux-training.be bGludXgtdHJhaW5pbmcuYmUK 
paul@ubu1110~$ base64 -d << bGludXgtdHJhaW5pbmcuYmUK linux-training.be

 
Для получения дополнительной информации об алгоритме base64 следует обратиться к стандарту rfc 3548.
---------------------------------------------------------

Неоднозначное перенаправление потоков ввода/вывода

Командная оболочка будет осуществлять разбор всей строки команды перед осуществлением перенаправления потоков ввода/вывода. Следующая команда является хорошо читаемой и корректной:
cat winter.txt > snow.txt 2> errors.txt


Но следующая команды также является корректной, хотя и хуже читается:
2> errors.txt cat winter.txt > snow.txt

 
Даже следующая команда будет прекрасно интерпретироваться командной оболочкой:
< winter.txt > snow.txt 2> errors.txt cat
-----------------------------------------------------

Быстрая очистка содержимого файла

Так какой же самый быстрый способ очистки содержимого файла?
>foo

А какой самый быстрый способ очистки содержимого файла в случае активации параметра командной оболочки noclobber?
>|bar

---------------------------------------------------------------
=====================================================================
Фильтр cut
Фильтр cut может использоваться для извлечения данных из столбцов расположенных в файлах таблиц с указанием разделителя столбцов или количества байт данных в столбцах. В примере ниже фильтр cut используется для извлечения имени пользователя и его идентификатора из файла /etc/passwd. В качестве разделителя столбцов таблицы из данного файла используется символ двоеточия, при этом производится выборка значений первого и третьего столбцов.

[paul@RHEL4b pipes]$ cut -d: -f1,3 /etc/passwd | tail -4 
Figo:510
Pfaff:511
Harry:516
Hermione:517
[paul@RHEL4b pipes]$


В случае использования фильтра cut с символом пробела в качестве разделителя вам придется экранировать этот символ пробела.

[paul@RHEL4b pipes]$ cut -d" " -f1 tenn is.txt 
Amelie
Kim
Justine
Serena
Venus
[paul@RHEL4b pipes]$


А в данном примере фильтр cut используется для вывода фрагментов строк файла /etc/passwd со второго по седьмой символ.

[paul@RHEL4b pipes]$ cut -c2-7 /etc/passwd | tail -4
igo:x:
faff:x
arry:x
ermion
[paul@RHEL4b pipes]$
===================================================================================

Фильтр tr
Вы можете преобразовывать символы с помощью фильтра tr. В примере ниже показана процедура преобразования всех обнаруженных в потоке данных символов e в символы E.

[paul@RHEL4b pipes]$ cat tennis.txt | tr 'e' 'E'
AmEliE MaurEsmo, Fra
Kim ClijstErs, BEL
JustinE HEnin, BEl
SErEna Williams, usa
VEnus Williams, USA


В данном случае мы переводим все буквенные символы в верхний регистр, указывая два диапазона значений.

[paul@RHEL4b pipes]$ cat tennis.txt | tr 'a-z' 'A-Z'
AMELIE MAURESMO, FRA
KIM CLIJSTERS, BEL
JUSTINE HENIN, BEL
SERENA WILLIAMS, USA
VENUS WILLIAMS, USA
[paul@RHEL4b pipes]$


А здесь мы преобразовываем все символы новых строк в символы пробелов.

[paul@RHEL4b pipes]$ cat count.txt 
один
два
три
четыре
пять
[paul@RHEL4b pipes]$ cat count.txt | tr '\n' ' '
один два три четыре пять [paul@RHEL4b pipes]$


Параметр tr -s также может использоваться для преобразования последовательностей из множества заданных символов в один символ.

[paul@RHEL4b pipes]$ cat spaces.txt 
один    два        три
     четыре   пять  шесть
[paul@RHEL4b pipes]$ cat spaces.txt | tr -s ' '
один два три
 четыре пять шесть
[paul@RHEL4b pipes]$


Вы можете использовать фильтр tr даже для 'шифрования' текстов с использованием алгоритма rot13.

[paul@RHEL4b pipes]$ cat count.txt
one
two
three
four
five
[paul@RHEL4b pipes]$ cat count.txt | tr 'a-z' 'nopqrstuvwxyzabcdefghijklm'
bar
gjb
guerr
sbhe
svir
[paul@RHEL4b pipes]$ cat count.txt | tr 'a-z' 'n-za-m'
bar
gjb
guerr
sbhe
svir
[paul@RHEL4b pipes]$


В последнем примере мы используем параметр tr -d для удаления заданного символа.

paul@debian5:~/pipes$ cat tennis.txt | tr -d e
Amli Maursmo, Fra
Kim Clijstrs, BEL
Justin Hnin, Bl
Srna Williams, usa
Vnus Williams, USA
----------------------------------------------------------------------

Фильтр wc
Подсчет слов, строк и символов в файле осуществляется достаточно просто в случае использования фильтра wc.

[paul@RHEL4b pipes]$ wc tennis.txt 
  5  15 100 tennis.txt
[paul@RHEL4b pipes]$ wc -l tennis.txt 
5 tennis.txt
[paul@RHEL4b pipes]$ wc -w tennis.txt 
15 tennis.txt
[paul@RHEL4b pipes]$ wc -c tennis.txt 
100 tennis.txt
[paul@RHEL4b pipes]$
======================================================================

Фильтр sort
Фильтр sort по умолчанию сортирует строки файла в алфавитном порядке.

paul@debian5:~/pipes$ cat music.txt 
Queen
Brel
Led Zeppelin
Abba
paul@debian5:~/pipes$ sort music.txt 
Abba
Brel
Led Zeppelin
Queen


Но при этом фильтр sort поддерживает большое количество параметров, позволяющих повлиять на принцип его работы. В следующем примере показана методика сортировки строк на основе значений различных столбцов (столбца 1 и столбца 2 соответственно).

[paul@RHEL4b pipes]$ sort -k1 country.txt 
Belgium, Brussels, 10
France, Paris, 60
Germany, Berlin, 100
Iran, Teheran, 70
Italy, Rome, 50
[paul@RHEL4b pipes]$ sort -k2 country.txt 
Germany, Berlin, 100
Belgium, Brussels, 10
France, Paris, 60
Italy, Rome, 50
Iran, Teheran, 70


В примере ниже продемонстрировано различие между сортировкой в алфавитном порядке и сортировкой по числовым значениям (обе сортировки осуществлены на основе значений из третьего столбца).

[paul@RHEL4b pipes]$ sort -k3 country.txt 
Belgium, Brussels, 10
Germany, Berlin, 100
Italy, Rome, 50
France, Paris, 60
Iran, Teheran, 70
[paul@RHEL4b pipes]$ sort -n -k3 country.txt 
Belgium, Brussels, 10
Italy, Rome, 50
France, Paris, 60
Iran, Teheran, 70
Germany, Berlin, 100
===============================================================


Фильтр uniq
С помощью фильтра uniq вы можете удалить повторяющиеся строки из отсортированного списка строк.

paul@debian5:~/pipes$ cat music.txt 
Queen
Brel
Queen
Abba
paul@debian5:~/pipes$ sort music.txt 
Abba
Brel
Queen
Queen
paul@debian5:~/pipes$ sort music.txt |uniq
Abba
Brel
Queen


Также в случае использования параметра -c фильтр uniq может вести подсчет повторений строк.

paul@debian5:~/pipes$ sort music.txt |uniq -c
      1 Abba
      1 Brel
      2 Queen

-----------------------------------------------------------------

Фильтр comm
Сравнение потоков данных (или файлов) может быть осуществлено с помощью фильтра comm. По умолчанию фильтр comm будет выводить данные в трех столбцах. В данном примере строки Abba, Cure и Queen присутствуют в списках из обоих файлов, строки Bowie и Sweet только в списке из первого файла, а строка Turnet - только в списке из второго файла.

paul@debian5:~/pipes$ cat > list1.txt
Abba
Bowie
Cure
Queen
Sweet
paul@debian5:~/pipes$ cat > list2.txt
Abba
Cure
Queen
Turner
paul@debian5:~/pipes$ comm list1.txt list2.txt 
                Abba
Bowie
                Cure
                Queen
Sweet
        Turner


Вывод фильтра comm лучше читается в случае формирования одного столбца. При этом с помощью цифровых параметров должны быть указаны столбцы, содержимое которых не должно выводиться.

paul@debian5:~/pipes$ comm -12 list1.txt list2.txt 
Abba
Cure
Queen
paul@debian5:~/pipes$ comm -13 list1.txt list2.txt 
Turner
paul@debian5:~/pipes$ comm -23 list1.txt list2.txt 
Bowie
Sweet
--------------------------------------------------------------------------

Фильтр od
Несмотря на то, что жители Европы предпочитают работать с символами ascii, компьютеры используют байты для хранения данных файлов. В примере ниже создается простой файл, после чего для показа его содержимого в форме шестнадцатеричных значений байт используется фильтр od.

paul@laika:~/test$ cat > text.txt
abcdefg
1234567
paul@laika:~/test$ od -t x1 text.txt 
0000000 61 62 63 64 65 66 67 0a 31 32 33 34 35 36 37 0a
0000020


Содержимое этого же файла может быть выведено и в форме восьмеричных значений байт.

paul@laika:~/test$ od -b text.txt 
0000000 141 142 143 144 145 146 147 012 061 062 063 064 065 066 067 012
0000020


А это содержимое рассматриваемого файла в форме символов ascii (или экранированных символов).

paul@laika:~/test$ od -c text.txt 
0000000   a   b   c   d   e   f   g  \n   1   2   3   4   5   6   7  \n
0000020
-------------------------------------------------------------------------------

Фильтр sed
Фильтр sed (расшифровывается как stream editor - редактор потока данных) позволяет выполнять различные операции редактирования при обработке потока данных с задействованием регулярных выражений.

paul@debian5:~/pipes$ echo уровень5 | sed 's/5/42/'
уровень42
paul@debian5:~/pipes$ echo уровень5 | sed 's/уровень/переход/'
переход5


Следует добавить флаг регулярного выражения g для осуществления глобальной замены (замены всех вхождений заданной строки в строку из потока данных).

paul@debian5:~/pipes$ echo уровень5 уровень7 | sed 's/уровень/переход/'
переход5 уровень7
paul@debian5:~/pipes$ echo уровень5 уровень7 | sed 's/уровень/переход/g'
переход5 переход7


С помощью флага регулярного выражения d вы можете осуществить удаление строк, содержащих заданную последовательность символов, из потока данных.

paul@debian5:~/test42$ cat tennis.txt 
Venus Williams, USA
Martina Hingis, SUI
Justine Henin, BE
Serena williams, USA
Kim Clijsters, BE
Yanina Wickmayer, BE
paul@debian5:~/test42$ cat tennis.txt | sed '/BE/d'
Venus Williams, USA
Martina Hingis, SUI
Serena williams, USA
--------------------------------------------------------------------------------
===================================================================================

Примеры конвейеров

Конвейер who | wc
Сколькими пользователями был осуществлен вход в систему?

[paul@RHEL4b pipes]$ who
root     tty1         июл 25 10:50
paul     pts/0        июл 25 09:29 (laika)
Harry    pts/1        июл 25 12:26 (barry)
paul     pts/2        июл 25 12:26 (pasha)
[paul@RHEL4b pipes]$ who | wc -l
4


Конвейер who | cut | sort
Вывод отсортированного списка пользователей, осуществивших вход в систему.

[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort
Harry
paul
paul
root


Вывод отсортированного списка пользователей, осуществивших вход в систему, в котором имя каждого пользователя приводится лишь единожды.

[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort | uniq
Harry
paul
root


Конвейер grep | cut
Вывод списка всех учетных записей пользователей, использующих командную оболочку bash на данном компьютере. Учетные записи пользователей будут подробно обсуждаться позднее.

paul@debian5:~$ grep bash /etc/passwd
root:x:0:0:root:/root:/bin/bash
paul:x:1000:1000:paul,,,:/home/paul:/bin/bash
serena:x:1001:1001::/home/serena:/bin/bash
paul@debian5:~$ grep bash /etc/passwd | cut -d: -f1
root
paul
serena
=========================================================================
*************************************************************************
=========================================================================

locate

Утилита locate имеет значительное отличие от утилиты find, заключающееся в том, что она использует данные индексирования файловой системы для установления путей к файлам. Несмотря на то, что данный алгоритм поиска гораздо быстрее алгоритма с обходом всех директорий файловой системы, в случае его использования данные о файловой системе в подавляющем большинстве случаев являются устаревшими. В том случае, если данные индексирования файловой системы еще не собраны, вам придется осуществить их сбор путем выполнения команды updatedb (в дистрибутиве Red Hat Enterprise Linux для выполнения описанной операции понадобятся привилегии пользователя root). 

[paul@RHEL4b ~]$ locate Samba
locate: не удалось выполнить stat () "/var/lib/mlocate/mlocate.db": Нет такого файла или каталога
[paul@RHEL4b ~]$ updatedb 
updatedb: не удалось открыть временный файл для "/var/lib/mlocate/mlocate.db"
[paul@RHEL4b ~]$ su -
Password: 
[root@RHEL4b ~]# updatedb
[root@RHEL4b ~]#

В большинстве дистрибутивов Linux для исполнения команды updatedb один раз в день используется планировщик задач. 
=========================================================================
*************************************************************************
=========================================================================

date
Утилита date
Утилита date может использоваться для вывода информации о дате, времени, часовом поясе, а также дополнительной информации.

paul@rhel55 ~$ date
Sat Apr 17 12:44:30 CEST 2010

Форматирование строки с информацией о дате может быть изменено в соответствии с вашими предпочтениями. Обратитесь к странице руководства для получения информации о других параметрах форматирования.

paul@rhel55 ~$ date +'%A %d-%m-%Y'
Суббота 17-04-2010

Во всех системах Unix для подсчета времени используется количество секунд, прошедших с 1969 года (первой секундой является первая секунда первого дня января 1970 года). Для вывода времени Unix в секундах может использоваться команда date +%s.

paul@rhel55 ~$ date +%s
1271501080

Когда же значение этого счетчика достигнет двух миллиардов секунд?

paul@rhel55 ~$ date -d '1970-01-01 + 2000000000 seconds'
Ср май 18 03:33:20 MSK 2033
=========================================================================
*************************************************************************
=========================================================================

Утилита cal
Утилита cal выводит календарь для текущего месяца, в котором выделен текущий день.

     Апрель 2010     
Пн Вт Ср Чт Пт Сб Вс
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30


Вы можете выбрать любой месяц из прошлого или будущего.

paul@rhel55 ~$ cal 2 1970
   Февраль 1970    
Пн Вт Ср Чт Пт Сб Вс
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28

=========================================================================
*************************************************************************
=========================================================================

Утилита sleep
Утилита sleep иногда используется в сценариях для перехода в режим ожидания на заданный промежуток времени в секундах. В данном примере показана методика реализации пятисекундного периода ожидания с использованием утилиты sleep.

paul@rhel55 ~$ sleep 5
paul@rhel55 ~$

=========================================================================
*************************************************************************
=========================================================================

Команда time
Команда time выводит информацию о том, сколько времени тратится на исполнение заданной команды. На исполнение команды date тратится совсем немного времени.

paul@rhel55 ~$ time date
Суб Апр 17 13:08:27 CEST 2010

real    0m0.014s
user    0m0.008s
sys     0m0.006s


Команда sleep 5 исполняется в течение пяти секунд реального времени, но при этом на ее исполнение тратится совсем немного процессорного времени.

paul@rhel55 ~$ time sleep 5

real    0m5.018s
user    0m0.005s
sys     0m0.011s


А на исполнение команды bzip2, осуществляющей сжатие файла, тратится достаточно много процессорного времени.

paul@rhel55 ~$ time bzip2 text.txt 

real    0m2.368s
user    0m0.847s
sys     0m0.539s

=========================================================================
*************************************************************************
=========================================================================

Утилиты zcat - zmore
Содержимое текстовых файлов, сжатых с помощью утилиты gzip, может быть просмотрено с помощью утилит zcat и zmore.

paul@rhel55 ~$ head -4 text.txt 
/
/opt
/opt/VBoxGuestAdditions-3.1.6
/opt/VBoxGuestAdditions-3.1.6/routines.sh
paul@rhel55 ~$ gzip text.txt 
paul@rhel55 ~$ zcat text.txt.gz | head -4
/
/opt
/opt/VBoxGuestAdditions-3.1.6
/opt/VBoxGuestAdditions-3.1.6/routines.sh
-------------------------------------------------------------------------

Утилиты bzcat - bzmore
И, аналогичным образом, с помощью утилит bzcat и bzmore может осуществляться вывод содержимого файлов, сжатых с использованием утилиты bzip2.

paul@rhel55 ~$ bzip2 text.txt 
paul@rhel55 ~$ bzcat text.txt.bz2 | head -4
/
/opt
/opt/VBoxGuestAdditions-3.1.6
/opt/VBoxGuestAdditions-3.1.6/routines.sh

=========================================================================
*************************************************************************
=========================================================================

                   Утилита rename

Реализации утилиты rename
В дистрибутиве Debain Linux по пути /usr/bin/rename расположена ссылка на сценарий /usr/bin/prename, устанавливаемый из пакета perl.

paul@pi ~ $ dpkg -S $(readlink -f $(which rename))
perl: /usr/bin/prename


В дистрибутивах, основанных на дистрибутиве Red Hat, не создается аналогичной символьной ссылки для указания на описанный сценарий (конечно же, за исключением тех случаев, когда создается символьная ссылка на сценарий, установленный вручную), поэтому в данном разделе не будет описываться реализация утилиты rename из дистрибутива Red Hat.

В дискуссиях об утилите rename в сети Интернет обычно происходит путаница из-за того, что решения, которые отлично работают в дистрибутиве Debian (а также Ubuntu, xubuntu, Mint, ...), не могут использоваться в дистрибутиве Red Hat (а также CentOS, Fedora, ...).

Пакет perl
Команда rename на самом деле реализована в форме сценария, использующего регулярные выражения языка программирования perl. С полным руководством по использованию данного сценария можно ознакомиться после ввода команды perldoc perlrequick (после установки пакета perldoc).

root@pi:~# aptitude install perl-doc
Следующие НОВЫЕ пакеты будут установлены:
  perl-doc
0 пакетов обновлено, 1 установлено новых, 0 пакетов отмечено для удаления, и 0 пакетов не обновлено.
Необходимо получить 8,170 kB архивов. После распаковки 13.2 MB будет занято.
Получить: 1 http://mirrordirector.raspbian.org/raspbian/ wheezy/main perl-do...
Получено 8,170 kБ в 19с (412 kБ/с)
Выбор ранее не выбранного пакета perl-doc.
(Чтение базы данных ... на данный момент установлено 67121 файл и каталог.)
Распаковывается perl-doc (из .../perl-doc_5.14.2-21+rpi2_all.deb) ...
Adding 'diversion of /usr/bin/perldoc to /usr/bin/perldoc.stub by perl-doc'
Обрабатываются триггеры для man-db ...
Настраивается пакет perl-doc (5.14.2-21+rpi2) ...

root@pi:~# perldoc perlrequick
--------------------------------------------------------------

 Хорошо известный синтаксис

Чаще всего утилита rename используется для поиска файлов с именами, соответствующими определенному шаблону в форме строки, и замены данной строки на другую строку.
Обычно данное действие описывается с помощью регулярного выражения s/строка/другая строка/, как показано в примере:

paul@pi ~ $ ls
abc       allfiles.TXT  bllfiles.TXT  Scratch   tennis2.TXT
abc.conf  backup        cllfiles.TXT  temp.TXT  tennis.TXT
paul@pi ~ $ rename 's/TXT/text/' *
paul@pi ~ $ ls
abc       allfiles.text  bllfiles.text  Scratch    tennis2.text
abc.conf  backup         cllfiles.text  temp.text  tennis.text


А ниже приведен другой пример, в котором используется хорошо известный синтаксис утилиты rename для повторного изменения расширений тех же файлов:

paul@pi ~ $ ls
abc       allfiles.text  bllfiles.text  Scratch    tennis2.text
abc.conf  backup         cllfiles.text  temp.text  tennis.text
paul@pi ~ $ rename 's/text/txt/' *.text
paul@pi ~ $ ls
abc       allfiles.txt  bllfiles.txt  Scratch   tennis2.txt
abc.conf  backup        cllfiles.txt  temp.txt  tennis.txt
paul@pi ~ $


Эти два примера являются работоспособными по той причине, что используемые нами строки встречаются исключительно в расширениях файлов. Не забывайте о том, что расширения файлов не имеют значения при работе с командной оболочкой bash.
В следующем примере продемонстрирована проблема, с которой можно столкнуться при использовании данного синтаксиса.

paul@pi ~ $ touch atxt.txt
paul@pi ~ $ rename 's/txt/problem/' atxt.txt
paul@pi ~ $ ls
abc       allfiles.txt  backup        cllfiles.txt  temp.txt     tennis.txt
abc.conf  aproblem.txt  bllfiles.txt  Scratch       tennis2.txt
paul@pi ~ $


При исполнении рассматриваемой команды осуществляется замена исключительно первого вхождения разыскиваемой строки.

Глобальная замена

Синтаксис, использованный в предыдущем примере, может быть описан следующим образом: s/регулярное выражение/строка для замены/. Это описание является простым и очевидным, так как вам придется всего лишь разместить регулярное выражение между двумя первыми слэшами и строку для замены между двумя последними слэшами.
В следующем примере данный синтаксис немного расширяется благодаря добавлению модификатора.

paul@pi ~ $ rename -n 's/TXT/txt/g' aTXT.TXT
aTXT.TXT renamed as atxt.txt
paul@pi ~ $

Теперь используемый нами синтаксис может быть описан как s/регулярное выражение/строка для замены/g, где модификатор s обозначает операцию замены (switch), а модификатор g - сообщает о необходимости осуществления глобальной замены (global). 

Обратите внимание на то, что в данном примере был использован параметр -n для вывода информации о выполняемой операции (вместо выполнения самой операции, заключающейся в непосредственном переименовании файла). 
------------------------------------------------------------------

 Замена без учета регистра
Другим модификатором, который может оказаться полезным, является модификатор i. В примере ниже показана методика замены строки на другую строку без учета регистра.

paul@debian7:~/files$ ls
file1.text  file2.TEXT  file3.txt
paul@debian7:~/files$ rename 's/.text/.txt/i' *
paul@debian7:~/files$ ls
file1.txt  file2.txt  file3.txt
paul@debian7:~/files$
--------------------------------------------------------------------

 Изменение расширений

Интерфейс командной строки Linux не имеет представления о расширениях файлов, аналогичных применяемым в операционной системе MS-DOS, но многие пользователи и приложения с графическим интерфейсом используют их.
В данном разделе приведен пример использования утилиты rename для изменения исключительно расширений файлов. В примере используется символ доллара для указания на то, что точкой отсчета для замены является окончание имени файла.

paul@pi ~ $ ls *.txt
allfiles.txt  bllfiles.txt  cllfiles.txt  really.txt.txt  temp.txt  tennis.txt
paul@pi ~ $ rename 's/.txt$/.TXT/' *.txt
paul@pi ~ $ ls *.TXT
allfiles.TXT  bllfiles.TXT    cllfiles.TXT    really.txt.TXT
temp.TXT      tennis.TXT
paul@pi ~ $


Обратите внимание на то, что символ доллара в рамках регулярного выражения обозначает окончание строки. Без символа доллара исполнение данной команды должно завершиться неудачей в момент обработки имени файла really.txt.txt. 
--------------------------------------------------------------------------------------
======================================================================================
======================================================================================

Утилита whoami

Утилита whoami сообщит вам имя вашей учетной записи.

[paul@centos7 ~]$ whoami
paul
[paul@centos7 ~]$
--------------------------------------------------------------------------------------

Утилита who

Утилита who предоставит вам информацию о том, какие пользователи осуществили вход в систему.

[paul@centos7 ~]$ who
root     pts/0        2014-10-10 23:07 (10.104.33.101)
paul     pts/1        2014-10-10 23:30 (10.104.33.101)
laura    pts/2        2014-10-10 23:34 (10.104.33.96)
tania    pts/3        2014-10-10 23:39 (10.104.33.91)
[paul@centos7 ~]$
--------------------------------------------------------------------------------------

Команда who am i

В случае использования утилиты who в рамках команды who am i будет выведена только одна строка с информацией о вашей текущей сессии.

[paul@centos7 ~]$ who am i
paul     pts/1        2014-10-10 23:30 (10.104.33.101)
[paul@centos7 ~]$
--------------------------------------------------------------------------------------

Утилита w

Утилита w предоставляет информацию о пользователях, которые осуществили вход в систему, а также о том, чем они занимаются.

[paul@centos7 ~]$ w
 23:34:07 up 31 min,  2 users,  load average: 0.00, 0.01, 0.02
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0     23:07   15.00s  0.01s  0.01s top
paul     pts/1     23:30    7.00s  0.00s  0.00s w
[paul@centos7 ~]$
--------------------------------------------------------------------------------------

Утилита id

Утилита id предоставит вам информацию о вашем идентификаторе пользователя, основном идентификаторе группы, а также выведет список групп, в которых вы состоите.

paul@debian7:~$ id
uid=1000(paul) gid=1000(paul) группы=1000(paul)


В дистрибутивах RHEL/CentOS с помощью данной утилиты вы также можете получить информацию о контексте SELinux.

[root@centos7 ~]# id
uid=0(root) gid=0(root) группы=0(root) контекст=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
--------------------------------------------------------------------------------------

Утилита su для работы от лица другого пользователя

Утилита su позволяет пользователю запустить командную оболочку от лица другого пользователя.

laura@debian7:~$ su tania
Password:
tania@debian7:/home/laura$
--------------------------------------------------------------------------------------

Утилита su для работы от лица пользователя root
Да, вы также можете использовать утилиту su для работы от лица пользователя root в том случае, если знаете пароль пользователя root.

laura@debian7:~$ su root
Password:
root@debian7:/home/laura#
--------------------------------------------------------------------------------------

Утилита su для пользователя root
Вы должны знать пароль пользователя, от лица которого хотите работать, за исключением случая, когда вы входите в систему как пользователь root. Пользователь root может работать от лица любого существующего в системе пользователя, не зная пароля этого пользователя.

root@debian7:~# id
uid=0(root) gid=0(root) группы=0(root)
root@debian7:~# su - valentina
valentina@debian7:~$
--------------------------------------------------------------------------------------

Команда su - $имя_пользователя
По умолчанию при смене пользователя утилита su осуществляет сохранение переменных окружения командной оболочки. Для того, чтобы работать от лица другого пользователя в окружении командной оболочки целевого пользователя, следует применять команду su - с последующим вводом имени целевого пользователя.

root@debian7:~# su laura
laura@debian7:/root$ exit
exit
root@debian7:~# su - laura
laura@debian7:~$ pwd
/home/laura

Команда su -
В том случае, если после команды su или su -  не следует имени пользователя, считается, что целевым пользователем является пользователь root.

tania@debian7:~$ su -
Password:
root@debian7:~#
--------------------------------------------------------------------------------------

Запуск приложения от лица другого пользователя

Утилита sudo позволяет пользователю осуществлять запуск программ с привилегиями других пользователей. Для того, чтобы данная утилита работала, системный администратор должен отредактировать соответствующим образом файл /etc/sudoers. Данная утилита может оказаться полезной в случае возникновения необходимости делегирования административных задач другому пользователю (без передачи этому пользователю пароля пользователя root).

В примере ниже показана методика использования утилиты sudo. Пользователь paul получил право запускать утилиту useradd с привилегиями пользователя root. Это позволило пользователю paul создавать учетные записи новых пользователей в системе, не работая от лица пользователя root и не зная пароля пользователя root.
Исполнение первой введенной пользователем paul команды завершилось неудачей.

paul@debian7:~$ /usr/sbin/useradd -m valentina
useradd: Отказано в доступе
useradd: cannot lock /etc/passwd; try again later.


Но в случае использования sudo данная команда работает.

paul@debian7:~$ sudo /usr/sbin/useradd -m valentina
[sudo] password for paul:
paul@debian7:~$
--------------------------------------------------------------------------------------

Утилита visudo

Изучите страницу руководства утилиты visudo перед редактированием файла /etc/sudoers. Методика редактирования файла sudoers выходит за пределы набора тем, рассматриваемых в рамках данной книги.

paul@rhel65:~$ apropos visudo
visudo               (8)  - edit the sudoers file
paul@rhel65:~$
--------------------------------------------------------------------------------------

Команда sudo su -

В некоторых дистрибутивах Linux, таких, как Ubuntu и Xubuntu пароль пользователя root изначально не установлен. Это значит, что не имеется возможности войти в систему под именем пользователя root (по сути это дополнительная мера безопасности). Для выполнения задач от лица пользователя root первому пользователю системы предоставляется возможность использования утилиты sudo благодаря добавлению специальной записи в файл /etc/sudoers. Фактически все пользователи, являющиеся членами группы admin, также могут использовать утилиту sudo для исполнения команд от лица пользователя root.

root@laika:~# grep admin /etc/sudoers 
# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL


В результате пользователь может ввести команду sudo su - и работать от лица пользователя root без ввода пароля пользователя root. При этом команда sudo требует ввода пароля вызвавшего ее пользователя. Исходя из вышесказанного, можно сделать вывод о том, что запрос пароля из примера ниже выполняется утилитой sudo, а не su.

paul@laika:~$ sudo su -
Password:
root@laika:~#
--------------------------------------------------------------------------------------


Журналирование неудачных попыток использования утилиты sudo

Использование утилиты sudo без авторизации приведет к выводу строгого предупреждения.

paul@rhel65:~$ sudo su -

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for paul:
paul is not in the sudoers file.  This incident will be reported.
paul@rhel65:~$


После этого пользователь root сможет увидеть следующую запись в файле /var/log/secure в случае использования дистрибутива Red Hat (или /var/log/auth.log в случае использования дистрибутива Debian).

root@rhel65:~# tail /var/log/secure | grep sudo | tr -s ' '
Apr 13 16:03:42 rhel65 sudo: paul : user NOT in sudoers ; TTY=pts/0 ; PWD=\
/home/paul ; USER=root ; COMMAND=/bin/su -
root@rhel65:~#
--------------------------------------------------------------------------------------
======================================================================================
======================================================================================

СПИСОК ГРУПП

sudo usermod -aG docker kakarevich  добавить в группу docker

id  вывести всю информацию о пользователе
paul@rhel65:~$ id
1000

id -G  вывести только список групп текущего пользователя (Команда выводит идентификаторы групп)
paul@rhel65:~$ id -G
1000 4 24 27 30 46 118 128

id -Gn  вывести только список групп текущего пользователя (выведет ИМЕНА ГРУПП)
paul@rhel65:~$ id -Gn
kakarevich adm cdrom sudo dip plugdev lpadmin lxd sambashare docker

id -Gn имя_пользователя   (вывести сисок групп опр пользователя)
paul@rhel65:~$ id -Gn kakarevich
kakarevich adm cdrom sudo dip plugdev lpadmin lxd sambashare docker

groups  вывести только список групп текущего пользователя (выведет ИМЕНА ГРУПП)
paul@rhel65:~$ groups
kakarevich adm cdrom sudo dip plugdev lpadmin lxd sambashare docker

groups имя_пользователя   (вывести сисок групп опр пользователя)
paul@rhel65:~$ groups kakarevich
kakarevich adm cdrom sudo dip plugdev lpadmin lxd sambashare docker

--------------------------------------------------------------------------------------
======================================================================================
======================================================================================
source

Для перезагрузки переменных окружения из файла часто используется команда source.

Эта команда позволяет выполнить скрипт в текущем процессе оболочки bash. По умолчанию для выполнения каждого скрипта запускается отдельная оболочка bash, хранящая все его переменные и функции. После завершения скрипта всё это удаляется вместе с оболочкой. Команда source позволяет выполнить скрипт в текущем командном интерпретаторе, а это значит, что всё переменные и функции, добавленные в этом скрипте, будут доступны также и в оболочке после его завершения.

Синтаксис команды очень прост. Надо вызвать саму команду и передать ей путь к исполняемому файлу:

$ source путь_к_файлу аргументы

paul@rhel65:~$ vi losstsource
WEBSITE=losst
# Затем загрузим переменную из этого файла:
paul@rhel65:~$ source losstsource
# Теперь можно попытаться вывести содержимое переменной и убедиться, что всё работает:
paul@rhel65:~$ $WEBSITE
Однако, переменная есть только в текущем командном интерпретаторе, в других командных интерпретаторах её нет. Это отличие команды source от команды export, позволяющей экспортировать переменные окружения глобально.

Если выполняемому скрипту нужно передать параметры, можно это сделать, просто перечислив их после пути к файлу скрипта. Модифицируем наш скрипт, чтобы переменная бралась из первого параметра:

paul@rhel65:~$ cat losstsource
WEBSITE=$1
paul@rhel65:~$ source losstsource losst.ru
paul@rhel65:~$ echo $WEBSITE
losst.ru
paul@rhel65:~$ 


Аналогично работают и функции. Если объявить функцию в скрипте bash, а затем выполнить его с помощью команды source linux, то функция станет доступна в интерпретаторе:

paul@rhel65:~$ vi testsource
#!/bin/bash
print_site(){
echo "losst.ru"
}
paul@rhel65:~$ losstsource
#Теперь можно выполнить функцию print_site в терминале или любом другом скрипте:
paul@rhel65:~$ print_site
losst.ru
paul@rhel65:~$
--------------------------------

Для тех, кто знаком с программированием на языке Си, можно провести аналогию с директивой #include, делающей доступными в текущем файле функции из других файлов. Если файл, имя которого передано как параметр команде, не существует, она вернёт код возврата 1 и завершится:

paul@rhel65:~$ source losstanything
bash: losstanything: Нет такого файла или каталога
paul@rhel65:~$ echo  $?
1
paul@rhel65:~$ 
paul@rhel65:~$ echo  $?
0
paul@rhel65:~$ 


Вместо команды source можно использовать точку (.), однако здесь следует быть осторожными — между точкой и именем файла должен быть пробел для того, чтобы bash интерпретировал эту точку как отдельную команду, а не как часть имени файла:
paul@rhel65:~$ . losstsource
paul@rhel65:~$ print_site
losst.ru
paul@rhel65:~$ 

Однако, нельзя писать .losstsource или ./losstsource, потому что обозначение ./ — это уже отсылка на текущую директорию, скрипт будет выполнен как обычно.
--------------------------------------------------------------------------------------
======================================================================================
======================================================================================

Команда eval

Команда eval позволяет интерпретировать переданные аргументы как директивы сценария командной оболочки (результирующие команды исполняются). Данное обстоятельство позволяет использовать значение переменной в качестве переменной.

paul@deb503:~/test42$ answer=42
paul@deb503:~/test42$ word=answer
paul@deb503:~/test42$ eval x=\$$word ; echo $x
42


Как в командной оболочке bash, так и командной оболочке Korn shell аргументы могут экранироваться с помощью двойных кавычек.

kahlan@solexp11$ answer=42
kahlan@solexp11$ word=answer
kahlan@solexp11$ eval "y=\$$word" ; echo $y
42


Иногда команде eval необходимо передавать аргументы таким образом, чтобы командной оболочкой осуществлялся их корректный разбор. Рассмотрите приведенный ниже пример, в котором команда date принимает один параметр, являющийся строкой "1 week ago".

paul@debian6~$ date --date="1 week ago"
Чт мар  8 21:36:25 CET 2012


В том случае, если мы сохраняем данную команду в переменную, исполнение команды из этой переменной будет заканчиваться неудачей до того момента, когда мы начнем использовать команду eval.

paul@debian6~$ lastweek='date --date="1 week ago"'
paul@debian6~$ $lastweek
date: лишний операнд `ago"'
По команде `date --help' можно получить дополнительную информацию.
paul@debian6~$ eval $lastweek
Чт мар  8 21:36:39 CET 2012
--------------------------------------------------------------------------------------
======================================================================================
======================================================================================
Оператор (( ))

Оператор (( )) позволяет сравнивать числовые значения.

paul@deb503:~/test42$ (( 42 > 33 )) && echo true || echo false
true
paul@deb503:~/test42$ (( 42 > 1201 )) && echo true || echo false
false
paul@deb503:~/test42$ var42=42
paul@deb503:~/test42$ (( 42 == var42 )) && echo true || echo false
true
paul@deb503:~/test42$ (( 42 == $var42 )) && echo true || echo false
true
paul@deb503:~/test42$ var42=33
paul@deb503:~/test42$ (( 42 == var42 )) && echo true || echo false
false
--------------------------------------------------------------------------------------
======================================================================================
======================================================================================








